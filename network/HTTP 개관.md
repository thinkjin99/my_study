#http #applicationlayer

### 출처
* HTTP 완벽 가이드
* https://developer.mozilla.org/ko/docs/Web/HTTP/Overview#http_%EB%A9%94%EC%8B%9C%EC%A7%80 (MDN 가이드)
___
### 개요
* [[#HTTP란]]
* [[#HTTP의 구성원]]
* [[#리소스]]
* [[#URL]]
* [[#URL이 없던 암흑의 시대]]
* [[#HTTP 메시지]]
* [[#CURL을 활용해보기]]
___
### HTTP란

<span class = "red red-bg">HTTP는 웹에서 사용하는 통신 프로토콜을 말한다. 웹 브라우저, 서버, 어플리케이션은 모두 HTTP를 지키며 통신을 진행한다.</span>

HTTP는 웹 상에서 이미지, HTML, 동영상과 같은 멀티미디어 파일을 주고 받을 수 있게 만들어준다. 이때 **HTTP는 TCP 위에서 구동되기 때문에 주고 받는 데이터의 순서와 무결성을 보장**해준다. 

**HTTP는 클라이언트 - 서버 프로토콜로 각 개체는 정해진 HTTP 메시지를 주고 받아 통신을 진행**한다. 이때 클라이언트가 서버로 전송하는 메시지를 request 요청 처리 후 서버가 클라이언트에게 돌려주는 메시지를 response라고 한다.

![](https://my-study.s3.ap-northeast-2.amazonaws.com/HTTP%20%EA%B0%9C%EA%B4%80%20/%20Pasted%20image%2020240306171409.png)

____
### HTTP의 구성원

#### 클라이언트
**클라이언트는 user-agent로도 묘사되며 웹 상에서 사용자를 대표하는 도구**이다. 대부분의 경우 브라우저가 해당 역할을 수행한다.

**브라우저는 항상 요청을 보내는 개체**로 여러 웹서버에 동시 다발적으로 요청을 송신해 웹 페이지를 구성한다.  이후 브라우저는 클라이언트의 다양한 액션 정보를 리슨하고 이에 적합한 처리를 진행한다.

#### 웹 서버
웹서버는 클라이언트의 요청에 대한 문서나 처리를 제공하는 기계이다. 서버는 논리적으로는 단일 기기이지만 실질적으로 여러대가 존재하는 경우가 많다. 
여러 서버를 하나의 머신에서 운영하는 것도 가능하고 동일한 ip를 갖는 서버를 여러개 생성하는 것도 불가하지 않다.

#### 프록시
**클라이언트와 서버 사이 위치한 머신으로 HTTP를 이어 받고 전달하는 역할을 수행한다.** 프락시는 중개자로 동작하며 다음과 같은 목적을 위해 자주 활용된다.

* 보안
* 캐시
* 로드밸런싱
* 필터링

![](https://my-study.s3.ap-northeast-2.amazonaws.com/HTTP%20%EA%B0%9C%EA%B4%80%20/%20%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-03-06%20%EC%98%A4%ED%9B%84%205.31.15.png)

___
### 리소스

웹 리소스는 웹 콘텐츠의 원천으로 가장 기본적인 리소스는 파일 시스템의 정적 파일이다. (HTML, txt, png...)
하지만 리소스가 반드시 정적일 필요는 없으며 리소스는 요청에 따라 콘텐츠를 동적으로 생산할 수도 있다. 

**리소스는 각자 다양한 파일 타입을 가지기 때문에 HTTP는 웹에서 전송되는 리소스 각각에 MIME라는 데이터 포맷 라벨을 붙인다.**
MIME 타입을 통해 브라우저는 서버로 부터 전달 받은 파일의 타입을 확인하고 이에 따른 적절한 처리를 수행할 수 있다.

예를 들어 이미지 형식의 파일을 웹서버에 업로드 하고 이의 MIME 타입을 이미지로 적절히 설정해두지 않을 경우 해당 URL 접근시 이미지가 보이지 않고 이미지를 곧장 다운 되는 방식으로 동작한다.

예시는 아래와 같다. 아래의 링크는 MIME 타입을 이미지로 설정한 후 S3에 업로드한 카리나 사진이다. 해당 링크는 크롬으로 접속 시 이미지가 적절히 로딩 된다. 하지만 이 [링크](https://my-study.s3.ap-northeast-2.amazonaws.com/HTTP/karina.jpg) 로 접속시 동일한 사진이 다운되는 현상이 발생한다.
![300](https://my-study.s3.ap-northeast-2.amazonaws.com/HTTP/karina.jpg)

MIME 타입은 응답 헤더의 Content-type 헤더를 통해 지정할 수 있다. <span class="red red-bg">브라우저에서 자동으로 적절히 처리해주지만, 명시적 동작을 위해선 적절히 처리해줄 필요가 반드시 존재한다.</span>
___
### URL

<span class="red red-bg">URL은 브라우저가 정보를 찾는데 필요한 리소스의 위치를 말한다.</span> URL은 자원 식별자 중 하나의 요소로 리소스의 이름이 아닌 리소스의 위치를 기준으로 식별을 진행한다.

URL은 URN, URL로 이뤄진 URI(통합 자원 식별자)의 부분집합이지만 실질적으로 식별을 URL로만 수행하는 경우가 잦기 때문에 URI를 곧 URL로 표현하곤 한다.

아래와 같은 URL을 예시로 분석을 진행해보자.
https://www.op.gg/summoners/kr/Akaps-KR1

URL의 첫 부분인 **http는 스킴으로 웹 클라이언트가 리소스에 어떻게 접근해야 하는지** 알려준다. 이 경우 HTTP 프로토콜을 활용해 접근하라는 것을 명시해준다.

 `www.op.gg` 는 **서버의 위치**를 나타낸다. 이는 리소스가 어디서 호스팅 되고 있는지를 알려준다.
 
 `/summoners/kr/Akaps-KR1` 는 리소스의 경로로 **서버에 존재하는 로컬 리소스들 중에 요청 받은 리소스를 특정**한다.

흥미로운 점은 URL은 HTTP에서만 사용 가능한 것이 아니라는 점이다. 따라서 아래와 같은 URL도 사용 가능하다.

- `mailto:mjin1789@gmail.com`
- `ftp:ftp.usaint.ac.kr/student/info/grade.xlsx`
___
### URL이 없던 암흑의 시대

URL이 없던 시절에 친구와 파일을 공유한다고 가정해보자. 과거이므로 추억의 파일 스타크래프트 립버전 1.3.1을 공유한다 생각하자. 특정한 ftp 서버에 해당 파일을 올려놨을 경우 친구에게 이런 식으로 설명을해야 했을 것이다.

> 일단 `my_ftp.com`에 접속을 해 그리고 로그인 한 다음 `joljam` 디렉토리로 이동해 그리고 다운 받으면 돼.

이를 URL로 표현하면 다음과 같다. `ftp://my_ftp.com/joljam/starcraft_1.3.1` URL이 존재하면 위와 같은 복잡한 설명 대신 링크 하나만을 공유해주면 된다.

URL은 특정한 어플리케이션이 리소스에 접근할 수 있는 방법을 제공해준다. 이를 통해 애플리케이션은 각각의 리소스의 프로토콜에 맞춰 대응을 할 수 있고 지능적으로 동작할 수 있어진다. 

<b><u>브라우저는 URL을 활용해 각 리소스들을 영리하게 처리하고 접근함으로써 온라인 세상을 단순화 한다.</u></b>

> [!info]
>**URL은 정보를 찾는데 필요한 모든 것을 제공하며, 어디서 가져오는지 어떻게 가져오는지를 정의한다.**

___
### HTTP 메시지

**HTTP 메시지는  HTTP 통신에서 실제 통신 내용이 적히는 포맷**으로 초기와 1.1 버전까지는 사람이 읽을 수 있었으나 2.0 버전 이후 부터는 메시지가 압축 되면서 사람이 곧장 해석하는 것은 불가능해졌다. 

하지만 각 메시지의 의미 자체는 변화하지 않고 압축만 진행한 것이기 때문에 클라이언트는 압축을 진행하지 않은 가상의 HTTP/1.1 코드를 읽음으로써 요청을 해석할 수 있다.

메시지의 생김새는 다음과 같다. 이제 하나하나 분석해보자.
![](https://my-study.s3.ap-northeast-2.amazonaws.com/HTTP%20%EA%B0%9C%EA%B4%80%20/%20Pasted%20image%2020240306184553.png)

#### 메서드
메서드는 여러 종류의 요청 명령을 지원하며 모든 HTTP 요청 메시지는 한 개의 메서드를 갖는다. 메서드를 통해 서버는 본인이 수행할 작업의 종류를 파악할 수 있다.

메서드와 연관이 깊은 것이 REST API인데, REST API의 취지 자체가 **API를 각 작업의 목적에 맞게 메서드 별로 분리해 작성하는 것**에 존재하기 때문이다. 

메서드는 GET,POST, DELETE 등이 존재하며 이후에 REST와 함께 더욱 더 자세히 설명한다.

#### 패스
가져오려는 리소스의 경로로 호스트 다음의 URL을 의미한다. 서버의 해당 경로에서 자원을 가져온다.

#### 응답
응답은 다음과 같은 형태로 돌아온다.
![](https://my-study.s3.ap-northeast-2.amazonaws.com/HTTP%20%EA%B0%9C%EA%B4%80%20/%20Pasted%20image%2020240306185359.png)
응답에는 **상태코드라는 값이 존재하며 이를 통해 클라이언트는 서버의 상태를 파악할 수 있다.** 상태 코드는 사유구절과 같이 전송 되며  404 Not Found나 500 Internal Server Error가 대표적인 벡엔드 개발자를 화나게 하는 상태 코드이다.
___
### CURL을 활용해보기

CURL을 활용하면 CLI 환경에서 별도의 소스코드 작성 없이 곧장 HTTP 테스트를 진행해 볼 수 있다. 아래의 예제를 보자.

```terminal
curl -X GET www.naver.com
```

아래와 같이 터미널에 명령어를 입력할 경우 CURL이 자동적으로 TCP 커넥션 생성 부터 HTTP 메시지 전송까지 전반적인 작업을 전부 진행해 준다.

응답 메시지를 자세히 확인하고 싶은 경우 다음의 옵션을 사용하면 된다.

```terminal
curl -i -X GET www.naver.com
```

CURL의 옵션을 활용할 경우 헤더 정보 또한 입력할 수 있고 모든 HTTP 요청을 흉내낼 수 있으므로 유용하게 활용할 수 있다.

또한 크롬 개발자 도구를 통해 특정 HTTP 리퀘스트를 CURL을 통해 추출해 터미널에서 테스트하는 방법 또한 가능하다.