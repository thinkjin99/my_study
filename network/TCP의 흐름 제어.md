#tcp 
### 출처
* https://evan-moon.github.io/2019/11/22/tcp-flow-control-error-control/ (TCP의 흐름제어)
___
### 개요
* [[#TCP의 흐름제어]]
* [[#Stop and Wait]]
* [[#Sliding Window]]
* [[#오류 제어]]
___
### TCP의 흐름제어

네트워크를 통해 통신하는 송, 수신측의 어플리케이션의 상태는 유동적이다. 프로세스 실행 중 블락이나 메모리 부족 등의 상황이 발생할 수 있고 이에 영향을 받아 송 수신 속도가 변화 할 수 있다. 이때 **데이터 수신 측에 부하가 발생할 경우 처리 속도가 감소하며 데이터가 버퍼를 가득 채우고 이후 버려지는 현상**을 확인 할 수 있다. 

TCP는 전송의 신뢰성을 보장해야 하기에 이를 방지하기 위해 꾸준히 송신 측에게 자신의 처리 상태를 알려야 한다. <span class="red red-bg"><b>TCP의 흐름제어는 이를 위해 사용하는 기법으로 상대방의 처리 속도와 네트워크 상황 등을 파악해 데이터의 전송 속도를 적절히 설정하는 기법들을 말한다.</b></span>

데이터 수신 측은 [[TCP 첫 걸음#TCP 세그먼트|TCP 세그먼트]]에 존재하는 윈도우 사이즈 값을 통해 현재의 처리 속도 및 버퍼의 현황을 송신 측에 전송하고 전송 측은 수신 측의 정보와 네트워크 상황을 참조해고 데이터 전송 속도를 조절한다.  
___
### Stop and Wait

![][https://evan-moon.github.io/static/65ff8e861f0894835574fb210cb11888/6af66/stop-and-wait.png]

캐치볼과 같은 방법으로 보낸 패킷에 대한 응답 패킷이 와야 다음 패킷을 전송하는 방법을 말한다. 데이터 전송을 보장할 수 있는 직관적인 방법이다. 하지만 한번에 한개씩만 전송이 가능하기 때문에 병렬성을 전혀 활용하지 못하는 비효율적인 전송 방식이다.
___
### Sliding Window
슬라이딩 윈도우는 연속해서 데이터를 전송하기 때문에 이를 정렬하고 중간에 전송 실패한 패킷이 존재할 때 별도의 처리가 필요하다. 이하에서는 슬라이딩 윈도우의 동작 방식에 대해 설명한다.

**슬라이딩 윈도우는 수신 측이 한번에 처리할 수 있는 데이터를 정해 놓고 이를 송신 측에 전송해 상태를 알려주는 방식**이다. 해당 방식의 장점은 <b><u>윈도우 크기 만큼의 데이터는 응답 없이 전송 받을 수 있기 때문에 연속성을 보장할 수 있다는 점</u></b>이다.

**윈도우 사이즈는 네트워크 환경과 수신 측의 상황에 영향을 받아 계속해서 크기가 변화**한다. 초기 윈도우 사이즈는 핸드 쉐이크를 통해 커넥션을 수립할 때 설정돼며 이후 RTT 값 등에 영향을 받아 변화한다.

![[Pasted image 20231227160835.png]]

슬라이딩 윈도우라는 이름이 붙은 이유는 정해진 윈도우 크기 만큼의 데이터를 계속해서 이동 시키면서 전송하기 때문이다. 아래의 이미지를 살펴보면 응답이 올 때마다 윈도우를 밀며 전송하는 방식을 확인할 수 있다. ACK 2가 왔을 때 송신 측은 윈도우를 2의 위치까지 이동시키고 다시 전송을 진행한다.

![[Pasted image 20231227161028.png]]

슬라이딩 윈도우의 상태는 아래와 같이 구분된다. **슬라이딩 윈도우는 ACK를 받은 패킷을 기준으로 윈도우 사이즈 만큼 전송하고 윈도우를 미는 행위를 반복하며 패킷을 연속 전송한다**. 이때 네트워크 환경에 맞춰 윈도우 사이즈를 조절하는 작업도 같이 진행한다.

![[Pasted image 20231227161358.png]]

슬라이딩 윈도우의 최대 크기는 65355 bytes로 제법 큰 크기가 된다. **큰 크기의 바이트를 응답 없이 연속 전송할 수 있기 때문에 슬라이딩 윈도우는 Stop-and-Wait 방식에 비해 속도가 빠르다. 또한 네트워크 환경이나 상황에 맞춰 윈도우 사이즈로 대응이 가능**하므로 현재의 TCP는 전부 슬라이딩 윈도우 방식을 채택하고 있다.
___
### 오류 제어

<span class="red red-bg"><b>TCP는 기본적으로 재전송을 통해 오류를 해결한다. 하지만 재전송 작업 자체의 오버헤드가 꽤 크기 때문에 최대한 재전송을 방지하는 것을 목표로 여러가지 방법을 사용한다.</b></span>

**재전송이 발생하는 경우는 응답이 타임아웃이 지나도록 돌아오지 않을 때 혹은 명시적으로 NACK가 올 때 혹은 중복된 ACK가 오는 경우 등이 존재한다**. 이때 NACK를 사용하면 NACK에 대한 ACK 처리를 별도로 작업해야 하기에 ACK만을 활용해 오류 감지를 하고 재전송을 진행한다.
#### Go Back N
<b><u>Go Back N 방식은 오류가 발생한 부분 부터 재전송을 진행하는 방식이다. 수신 측은 오류가 발생한 지점 이후의 패킷을 전부 폐기 처리하고 전체를 다시 재전송 받는다. </b></u>연속적으로 데이터를 보내는 슬라이딩 윈도우 방식과 잘 맞는 방식이다.

![[Pasted image 20231227165039.png]]

#### Selective Repeat
**Go Back N의 단점을 개선해 에러가 발생한 부분만 재전송 하는 방법**이다. 재전송의 크기는 Go Back N 보다 작지만, **오류가 난 패킷만 다시 전송하기에 패킷이 순차대로 저장되지 않는 문제가 발생**한다. 따라서 **순서를 보장하기 위해선 별도의 버퍼에서 데이터를 정렬**해야한다. 만약 정렬 작업의 오버헤드가 더 큰 경우 Go Back N을 사용하는 것이 더 유리할 수 있다.

![[Pasted image 20231227165628.png]]
