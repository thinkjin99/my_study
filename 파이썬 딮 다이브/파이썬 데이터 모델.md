### 개요
* [[#파이썬의 모든 것은 객체]]
* [[#파이썬 데이터 모델]]
* [[#데이터 모델과 통일성]]
* [[#카드 한뭉치]]
* [[#파이썬의 덕 타이핑 (근본 없음)]]
* [[#len() VS `__len__()`]]
___
### 출처
* https://dgkim5360.tistory.com/entry/python-duck-typing-and-protocols-why-is-len-built-in-function (덕 타이핑)
* https://stackoverflow.com/questions/2481421/difference-between-len-and-len (len vs __len__)
___
### 파이썬의 모든 것은 객체

<u><b>파이썬 프로그램에서 모든 데이터는 객체를 활용해 저장된다. 숫자, 문자열, 리스트, 함수, 클래스 심지어 모듈까지 모두 객체로 존재한다.</b></u> 파이썬 내부에는 원시 자료형의 개념이 존재하지 않으며 모든 데이터는 객체의 형태로 관리 된다. 아래 이미지는 1이 갖는 메서드를 나타낸다. 1은 단순한 값이 아니라 정수 객체로 취급된다.

![[Pasted image 20240104135225.png]]

> [!info]
> **객체 (Objects) 는 파이썬이 데이터(data)를 추상화한 것(abstraction)입니다. 
> 파이썬 프로그램의 모든 데이터는 객체나 객체 간의 관계로 표현됩니다.**

___
### 파이썬 데이터 모델

C언어는 메모리에 저장할 값의 종류에 따라 할당 받는 메모리 영역에 차이가 발생했다. char의 경우 1바이트 int의 경우 4바이트를 할당 받았고 이를 활용해 C언어에서는 각 자료형을 구분했다. **C에서의 자료형은 할당 받는 메모리의 크기를 직관적으로 보여주고 활용성을 높여주는 요소이다.** (int가 아니라 4byte이렇게 작성해서 변수 선언을 해야했다고 가정해보자...)

하지만 파이썬에서 타입은 C와 같이 단순히 메모리 크기의 차이만을 나타내지 않는다. 파이썬의 모든 것은 객체이기 때문이다. 파이썬은 객체 별로 다른 메서드를 가질 수 있고 다른 속성을 갖는 것도 가능하다. 이에 따라 파이썬은 기본 구성 단위들이 가져야할 메서드와 속성들을 정의해뒀는데 이것이 파이썬 데이터 모델이다. <span class="red red-bg"><b>데이터 모델은 일종의 프레임 워크로 시퀀스, 함수, 클래스, 이터레이터 등의 언어의 기본 구성단위에 대한 인터페이스를 정의한다.</b></span>

<u><b>언어의 기본 구성 단위라는 표현에 집중하자. 데이터 모델은 특정 타입에 대한 인터페이스를 정의하진 않는다.</b></u> 예를 들어 리스트를 만들려면 이러한 메서드와 속성을 갖고 있어야 한다 같은 인터페이스를 설정하진 않는다. 
<b><u>데이터 모델이 정의하는 것은 정확한 타입이 아닌 여러 타입 들이 속하는 추상적인 구조체이다. </b></u>

대표적으로 시퀀스를 생각해보자. 시퀀스는 데이터 모델이 정의하는 인터페이스 중 하나로get_item, contain, iter와 같은 매직 메서드들이 정의된 클래스라면 모두 시퀀스 형으로 취급이 가능하다. 이러한 인터페이스를 정의하는 것이 데이터 모델이다.

![][https://velog.velcdn.com/images/qsdcfd/post/cdd0f53b-0214-41a7-8dc9-e6642c899fd6/image.png]

___
### 데이터 모델과 통일성

데이터 모델을 사용하면 언어의 기본 구성 단위와 동일한 취급을 받는 객체를 생성할 수 있다는 것을 학습했다. <span class="red red-bg"><b>이를 활용하면 별도의 메서드를 생성할 필요 없이 언어 자체에 지원을 받는 코드를 작성할 수 있다.</b></span>예를 들어 for문을 사용해 순회가 가능한 나만의 자료형을 생성할 수 있다.

```python
class RangeIterator:
    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __iter__(self):
        # 이 객체 자체가 반복 가능하므로 self를 반환
        return self

    def __next__(self):
        # 현재 값이 범위를 벗어나면 StopIteration 예외를 발생시킴
        if self.start >= self.end:
            raise StopIteration
        else:
            # 현재 값 반환 후 다음 값으로 이동
            result = self.start
            self.start += 1
            return result

# RangeIterator를 사용하는 예제
if __name__ == "__main__":
    my_range = RangeIterator(1, 6)

    # for 문을 통한 반복
    for num in my_range:
        print(num)

```

만약 데이터 모델이 없었다면 별도의 메서드를 활용해 작업해야 했을 것이다. **데이터 모델은 이외에도 다양한 기능을 제공해 사용자 정의 객체가 마치 파이썬 기본 데이터 단위인 것 처럼 동작하게 만든다.** 

>[!info]
>**데이터 모델은 코드의 일관성에 큰 기여를 한다.**

___
### 카드 한뭉치

데이터 모델을 본격적으로 활용해 보자 아래는 파이썬으로 만든 카드 덱이다.

```python
import collections

Card = collections.namedtuple('Card',['rank','suit'])

class FrenchDeck:
    ranks = [str(n) for n in range(2,11)]+list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        self._cards=[Card(rank,suit) for suit in self.suits for rank in self.ranks]
    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]
```

카드 덱은 리스트나 튜플과 같이 인덱스를 활용해 접근이 가능한데 이는 `__getitem__`로 인해 가능한 일이다. 파이썬에서 foo[0]은 `foo.__getitem__(0)`으로 처리 된다. 슬라이싱과 같은 기능도 사용할 수 있다. FrenchDeck 인스턴스에서 [:3] 과 같은 연산도 `__getitem__`이 처리해주기 때문이다.
___
### 파이썬의 덕 타이핑 (근본 없음)

앞서 생성한 FrenchDeck 클래스는 iter 특별 메서드를 구현하지 않았음에도 동작하는데 이는 getitem 특별 메서드가 존재하기 때문이다. <b><u>파이썬은 인터페이스를 강제하지 않으며 만약 필요한 매직 메서드가 없을 경우 다른 메서드들을 활용해 동작 시킨다.</u></b>

파이썬은 이와 같은 덕 타이핑을 기본 철학으로 삼고 있으며 이는 이터레이터 말고 함수나 퓨쳐 객체 등에 댜양하게 적용 된다. 사용자는 이러한 특성을 활용해 더욱 유연한 코드를 작성할 수 있으나 자유도가 과하게 높다는 느낌도 든다.

```python
deck = FrenchDeck()
for d in deck: #getitem이 iter대신 이터러블로 변환 작업을 해준다.
	print(d)
```
___
### len() VS `__len__()`

일반적으로 특정한 객체의 길이를 구하는 작업은 해당 객체의 메서드나 속성으로 존재하곤 한다. 하지만 파이썬의 경우 메서드가 아닌 함수로 운영하고 있는데 이는 파이썬의 철학과 연관이 깊다. len이 메서드가 아닌 함수로 구현된 이유는 3가지 이다.

1. 더욱 명확하다
2. 더욱 안전하다
3. 더욱 빠르다

```python
>>> class bah(object):
...   def __len__(self): return "an inch"
... 
>>> bah().__len__()
'an inch'
>>> len(bah())
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object cannot be interpreted as an integer
```

`__len__`의 경우 클래스 마다 존재할 수 있고 사용자가 정의하는 것 또한 가능하기에 길이를 구하지 않고 다른 동작을 수행할 수 있다. 이에 따라 정수형이 아닌 타입을 반환하는 일도 가능하다. 이러한 상황은 코드의 명확성을 해치고 에러 발생율을 높인다.

**len의 경우 동작을 파이썬 내부에서 동작 하므로 사용자 이슈가 발생할 일이 없고 동작 자체도 pyObject가 갖고 있는 속성 데이터를 읽어 전달하는 방식이라 훨씬 빠른 속도로 동작한다.** 이에 따라 파이썬은 len 함수를 생성해 빠르고 명확한 형태로 구축했다.

